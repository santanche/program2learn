<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Micro Agent â€“ Final Stable Version</title>

<style>
body {
    font-family: monospace;
    display: flex;
    gap: 20px;
}

#leftPanel { width: 350px; }

textarea {
    width: 100%;
    height: 220px;
}

button {
    width: 100%;
    margin-top: 5px;
    padding: 6px;
}

canvas {
    border: 2px solid black;
    image-rendering: pixelated;
}
</style>
</head>
<body>

<div id="leftPanel">
<h3>Program</h3>

<textarea id="code">
(
  ?U F
  ?B R
)*
</textarea>

<button type="button" onclick="compileProgram()">Compile</button>
<button type="button" onclick="run()">Run</button>
<button type="button" onclick="pause()">Pause</button>
<button type="button" onclick="step()">Step</button>
<button type="button" onclick="resetWorld()">Reset</button>

<label>Speed</label>
<input type="range" min="50" max="1000" value="400" id="speedSlider">

<label>Zoom</label>
<input type="range" min="16" max="64" value="32" id="zoomSlider">
</div>

<canvas id="gridCanvas"></canvas>

<script>

// ===========================
// GLOBAL STATE
// ===========================

const rows = 15;
const cols = 15;

let cellSize = 32;
let grid = [];
let agent = {};
let direction = 0;

let controlStack = [];
let running = false;
let timer = null;

const canvas = document.getElementById("gridCanvas");
const ctx = canvas.getContext("2d");

// ===========================
// SPRITES
// ===========================

const trilobiteImg = new Image();
const sandImg = new Image();
const rockImg = new Image();

trilobiteImg.src = "trilobite.png";
sandImg.src = "sand.png";
rockImg.src = "rock.png";

// Wait for ALL images before starting
Promise.all([
    new Promise(res => trilobiteImg.onload = res),
    new Promise(res => sandImg.onload = res),
    new Promise(res => rockImg.onload = res)
]).then(init);

// ===========================
// INITIALIZATION
// ===========================

function init() {
    initGrid();
    initAgent();
    resizeCanvas();
}

function initGrid() {
    grid = [];
    for (let r=0; r<rows; r++) {
        let row=[];
        for (let c=0; c<cols; c++)
            row.push("sand");
        grid.push(row);
    }
}

function initAgent() {
    agent.row = Math.floor(rows/2);
    agent.col = Math.floor(cols/2);
    direction = 0;
}

function resizeCanvas(){
    canvas.width = cols * cellSize;
    canvas.height = rows * cellSize;
    render();
}

document.getElementById("zoomSlider")
.addEventListener("input", e=>{
    cellSize = parseInt(e.target.value);
    resizeCanvas();
});

// ===========================
// RENDER
// ===========================

function render() {

    ctx.clearRect(0,0,canvas.width,canvas.height);

    for (let r=0; r<rows; r++){
        for (let c=0; c<cols; c++){
            let img = grid[r][c]==="sand" ? sandImg : rockImg;
            ctx.drawImage(img, c*cellSize, r*cellSize, cellSize, cellSize);
        }
    }

    ctx.save();
    ctx.translate(agent.col*cellSize + cellSize/2,
                  agent.row*cellSize + cellSize/2);
    ctx.rotate(direction*Math.PI/2);
    ctx.drawImage(trilobiteImg,
                  -cellSize/2,
                  -cellSize/2,
                  cellSize,
                  cellSize);
    ctx.restore();
}

// ===========================
// GRID CLICK (NO SHIFT)
// ===========================

canvas.addEventListener("click", e=>{

    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;

    const x = (e.clientX - rect.left) * scaleX;
    const y = (e.clientY - rect.top) * scaleY;

    const c = Math.floor(x / cellSize);
    const r = Math.floor(y / cellSize);

    if (r>=0 && r<rows && c>=0 && c<cols) {
        grid[r][c] = grid[r][c]==="sand" ? "rock" : "sand";
        render();
    }
});

// ===========================
// PARSER
// ===========================

function tokenize(code){
    return code.match(/\?U|\?B|\(|\)\*|L|R|F/g) || [];
}

function parse(tokens){
    let pos=0;

    function parseProgram(){
        let stmts=[];
        while(pos<tokens.length && tokens[pos]!==")*")
            stmts.push(parseStmt());
        return stmts;
    }

    function parseStmt(){
        let token=tokens[pos++];

        if(["L","R","F"].includes(token))
            return {type:"action",value:token};

        if(token==="?U"||token==="?B")
            return {type:"conditional",test:token,stmt:parseStmt()};

        if(token==="("){
            let body=parseProgram();
            pos++; // skip )*
            return {type:"loop",body};
        }

        throw "Parse error";
    }

    return parseProgram();
}

// ===========================
// SEMANTICS
// ===========================

function frontCell(){
    const dr=[-1,0,1,0];
    const dc=[0,1,0,-1];
    return {r:agent.row+dr[direction],
            c:agent.col+dc[direction]};
}

function isUnblocked(){
    const f=frontCell();
    if(f.r<0||f.r>=rows||f.c<0||f.c>=cols)
        return false;
    return grid[f.r][f.c]==="sand";
}

// ONE TRUE SMALL STEP
function step(){

    if(controlStack.length===0) return;

    const node = controlStack.pop();

    if(node.type==="action"){

        if(node.value==="L")
            direction=(direction+3)%4;

        else if(node.value==="R")
            direction=(direction+1)%4;

        else if(node.value==="F" && isUnblocked()){
            const f=frontCell();
            agent.row=f.r;
            agent.col=f.c;
        }
    }

    else if(node.type==="conditional"){

        const cond = node.test==="?U"
            ? isUnblocked()
            : !isUnblocked();

        if(cond)
            controlStack.push(node.stmt);
    }

    else if(node.type==="loop"){

        // Re-push loop (infinite semantics)
        controlStack.push(node);

        // Push body in reverse order
        for(let i=node.body.length-1;i>=0;i--)
            controlStack.push(node.body[i]);
    }

    render();
}

// ===========================
// CONTROLS
// ===========================

function compileProgram(){

    pause();

    const code=document.getElementById("code").value;
    const tokens=tokenize(code);
    const ast=parse(tokens);

    controlStack=[];

    // push in reverse order
    for(let i=ast.length-1;i>=0;i--)
        controlStack.push(ast[i]);

    alert("Compiled successfully.");
}

function run(){
    if(running) return;
    running=true;
    const speed=document.getElementById("speedSlider").value;
    timer=setInterval(step,speed);
}

function pause(){
    running=false;
    clearInterval(timer);
}

function resetWorld(){
    pause();
    initGrid();
    initAgent();
    render();
}

</script>
</body>
</html>
